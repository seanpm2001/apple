\documentclass{article}

\begin{document}

\title{Apple Array Allocation}
\author{V. E. McHale}
\maketitle

\begin{abstract}
    Array languages like J and APL suffer from a lack of embedability in implementations. Adroit memory management can make embedding easier; one would like to avoid thinking about ownership across two garbage collectors. Here I present statically determined memory allocation used in the Apple array system. Ownership is simple and Apple code does not constrain memory management in the host language.
\end{abstract}

\section{Introduction}

Array libraries like NumPy take inspiration from J, but our approach embeds a full language. Procedures can be called from a variety of languages (C, Python, Haskell) with the same type system---specialized for arrays---without compromising in order to accomodate Python's lack of static typing or C's lack of sophistication. Moreover, an embedded language can perform deforestation or fusion, which is not possible with NumPy's library approach.

Since Apple is designed to be embedded in diverse host languages, we cannot commit to a particular garbage collector

The language is expression-oriented (immutable); there are no references.

\section{Method}

Our work is based on classical liveness algorithms %; we annotate statements with {\tt use}
% cite appel
%, though we must tag additional information when generating the IR.

% Let us reflect on this unexpected :
% no case/sum types... etc.

The IR used in the Apple compiler is sequences of statements and expressions.

\begin{verbatim}
data Exp = Const Int
         | Reg Temp
         | At ArrayExp
         ...

data Stmt = Malloc Int Temp Exp -- label, register, size
          | Write ArrayExp Exp
          ...
\end{verbatim}

As an example, suppose we wish to generate an array and extract the first element:

\begin{verbatim}
 > {. (irange 0 99 1)
0
\end{verbatim}

Under the hood:

\begin{verbatim}
 > :ir {. (irange 0 99 1)
(movtemp r_14 (int 0))
(movtemp r_15 (int 99))
(movtemp r_13 (+ (- (reg r_15) (reg r_14)) (int 1)))
(malloc r_12 : (+ (asl (reg r_13) (int 3)) (int 16)))
(write (ptr r_12) (int 1))
(write (ptr r_12+(int 8)) (reg r_13))
(movtemp r_16 (int 0))
(mjump (>= (reg r_16) (reg r_13)) apple_1)

apple_0:
(write (ptr r_12+(+ (asl (reg r_16) (int 3)) (int 16))) (reg r_14))
(movtemp r_14 (+ (reg r_14) (int 1)))
(movtemp r_16 (+ (reg r_16) (int 1)))
(mjump (< (reg r_16) (reg r_13)) apple_0)

apple_1:
(movtemp r_ret @(ptr r_12+(int 16)))
(free r_12)
\end{verbatim}

That is, the array that is allocated is freed precisely after all relevant operations have completed.

We must be careful when arranging loops;

% note that the way we exit loops matters

\section{Coda}

Apple has the potential to be far more efficient; one could consolidate allocations, e.g.

\begin{verbatim}
 irange 0 10 1 ++ irange 0 10 1
\end{verbatim}

performs two allocations (one for each {\tt irange 0 10 1}) but

\end{document}
