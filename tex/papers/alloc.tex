\documentclass{article}

\usepackage[margin=1.5in]{geometry}
\usepackage{tikz}
\usepackage{hyperref}

\begin{document}

\title{Apple Array Allocation}
\author{V. E. McHale}
\maketitle

\begin{abstract}
    Array languages like J and APL suffer from a lack of embedability in implementations. Adroit memory management can make embedding easier; one would like to avoid thinking about ownership across two garbage collectors and runtime linking is simpler. Here I present statically determined memory allocation used in the Apple array system, a JIT compiler. Ownership is simple and Apple code does not constrain memory management in the host language.
    % mention that it is actually used in Python and R and REPL
\end{abstract}

\section{Introduction}

Array libraries like NumPy take inspiration from J, but our approach embeds a full language. Procedures can be called from a variety of languages (C, Python, Haskell) with the same type system---specialized for arrays---without compromising in order to accommodate Python's lack of static typing or C's lack of sophistication. Moreover, an embedded compiler can perform deforestation and fusion, offering something over a shared library.

% Explain tuples are flat.

The language is expression-oriented (immutable); there are no references. This constraint, with extra bookkeeping information added during IR generation, is responsible for the surprising fact that memory allocation can be completely determined at compile time.

\section{Method}

Our work is based on classical liveness algorithms; we annotate statements with {\tt uses} and {\tt defs} and thence compute liveness intervals for arrays.

% We insert {\tt free}s mechanically, % frees are calculated and thence less fickle (double free/leftover)
% allocations are specified but not frees...

When generating the IR, we track each mention of the array with a label and associate the label with the temporary that can be used to free it.

\begin{verbatim}
data ArrayExp = ArrayPointer Temp (Maybe Exp) (Maybe Int) -- register, offset, label
\end{verbatim}
% show discipline of keeping label across two temps

% from stackexchange
\tikzset{
block/.style = {draw, minimum height=2.5em, minimum width=4em, node distance=1.75cm}
}

\begin{tikzpicture}[auto]
    \node [] (expr) {\ldots};
    \node [block, below of=expr] (plain) {\tt [Stmt]};
    \node [block, below of=plain] (live) {\tt [(Stmt, Liveness)]};
    \node [block, below of=live] (alloc) {\tt [Stmt]};
    \draw [->] (expr) -- node {IR Generation} (plain);
    \draw [->] (plain) -- node {Liveness Analysis} (live);
    \draw [->] (live) -- node {Insert Frees} (alloc);
\end{tikzpicture}

% cite appel
%, though we must tag additional information when generating the IR.

The IR used in the Apple compiler is sequences of statements and expressions.

\begin{verbatim}
data Exp = Const Int
         | Reg Temp
         | At ArrayExp
         ...

data Stmt = Malloc Int Temp Exp -- label, register, size
          | Write ArrayExp Exp
          | MovTemp Temp Exp
          ...
\end{verbatim}

\subsection{Generation}

We must be careful when arranging loops;

\subsection{At Work}

As an example, suppose we wish to generate an array and extract the first element:

\begin{verbatim}
 > {. (irange 0 99 1)
0
\end{verbatim}

Under the hood:

\begin{verbatim}
 > :ir {. (irange 0 99 1)
(movtemp r_14 (int 0))
(movtemp r_15 (int 99))
(movtemp r_13 (+ (- (reg r_15) (reg r_14)) (int 1)))
(malloc r_12 : (+ (asl (reg r_13) (int 3)) (int 16)))
(write (ptr r_12) (int 1))
(write (ptr r_12+(int 8)) (reg r_13))
(movtemp r_16 (int 0))
(mjump (>= (reg r_16) (reg r_13)) apple_1)

apple_0:
(write (ptr r_12+(+ (asl (reg r_16) (int 3)) (int 16))) (reg r_14))
(movtemp r_14 (+ (reg r_14) (int 1)))
(movtemp r_16 (+ (reg r_16) (int 1)))
(mjump (< (reg r_16) (reg r_13)) apple_0)

apple_1:
(movtemp r_ret @(ptr r_12+(int 16)))
(free r_12)
\end{verbatim}

That is, the array that is allocated is freed precisely after all relevant operations have completed.

% note that the way we exit loops matters

\section{Embeddings}

Apple has been embedded in Python and R.

\section{Coda}

Apple has the potential to be far more efficient; one could consolidate allocations, e.g.

\begin{verbatim}
 irange 0 10 1 ++ irange 0 10 1
\end{verbatim}

performs one allocation for each {\tt irange 0 10 1} but this could be consolidated into one using static type information---{\tt irange 0 10 1} has type {\tt Vec 10 int} and

\end{document}
